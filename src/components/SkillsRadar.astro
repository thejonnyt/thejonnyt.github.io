---
/**
 * SkillsRadar.astro - Interactive radar/spider chart for skill categories
 */
import skillsDatabase from '../content/skillsDatabase.json';

interface Props {
  size?: number;
}

const { size = 750 } = Astro.props;

// Map skill levels to numeric values (0-5)
const levelToValue: Record<string, number> = {
  'beginner': 1,
  'competent': 2,
  'proficient': 3,
  'expert': 4,
  'wizard': 5
};

// Calculate average proficiency and years of experience per category
const categoryStats: Record<string, {
  sumProficiency: number;
  sumExperience: number;
  count: number;
  skills: string[]
}> = {};

for (const key in skillsDatabase.skills) {
  const k = key as keyof typeof skillsDatabase.skills;
  const skill = skillsDatabase.skills[k];
  const category = skill.category;
  const proficiencyValue = levelToValue[skill.level] || 0;
  const experienceYears = skill.yearsOfExperience || 0;

  if (!categoryStats[category]) {
    categoryStats[category] = { sumProficiency: 0, sumExperience: 0, count: 0, skills: [] };
  }

  categoryStats[category].sumProficiency += proficiencyValue;
  categoryStats[category].sumExperience += experienceYears;
  categoryStats[category].count++;
  categoryStats[category].skills.push(key);
}

// Calculate averages and prepare data, filtering out Business & Strategy
const categories = Object.entries(categoryStats)
  .filter(([name]) => name !== 'Business & Strategy')
  .map(([name, stats]) => {
    const avgProficiency = stats.sumProficiency / stats.count;
    const avgExperience = stats.sumExperience / stats.count;
    // Scale experience: 5 years = 4.0 on visual scale
    const visualExperience = Math.min((avgExperience / 5) * 4, 4);

    const goal = skillsDatabase.categoryGoals?.[name];
    return {
      name,
      proficiency: avgProficiency,
      visualProficiency: Math.min(avgProficiency, 4), // Clamped to 4 for display
      experience: avgExperience,
      visualExperience: visualExperience,
      count: stats.count,
      skills: stats.skills,
      goal: goal || null,
      goalProficiency: goal?.proficiencyTarget || avgProficiency,
      visualGoalProficiency: Math.min(goal?.proficiencyTarget || avgProficiency, 4)
    };
  });

// SVG configuration
const center = size / 2;
const maxRadius = (size / 2) - 70; // More space for labels
const numCategories = categories.length;
const maxValue = 4; // Visual scale is 1-4

// Generate polygon points for the radar chart
const angleStep = (2 * Math.PI) / numCategories;

// Data points for proficiency
const proficiencyPoints = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2); // Start at top
  const radius = (cat.visualProficiency / maxValue) * maxRadius;
  const x = center + radius * Math.cos(angle);
  const y = center + radius * Math.sin(angle);
  return { x, y, angle, cat };
});

// Data points for experience
const experiencePoints = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const radius = (cat.visualExperience / maxValue) * maxRadius;
  const x = center + radius * Math.cos(angle);
  const y = center + radius * Math.sin(angle);
  return { x, y, angle, cat };
});

// Data points for goal proficiency (for extension visualization)
const goalProficiencyPoints = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const radius = (cat.visualGoalProficiency / maxValue) * maxRadius;
  const x = center + radius * Math.cos(angle);
  const y = center + radius * Math.sin(angle);
  return { x, y, angle, cat };
});

// Generate lines for migration animation
const migrationLines = categories.map((_, i) => {
  const from = proficiencyPoints[i];
  const to = goalProficiencyPoints[i];
  return {
    x1: from.x,
    y1: from.y,
    x2: to.x,
    y2: to.y,
    categoryIndex: i,
    // Only create a line if there's a difference
    visible: from.x !== to.x || from.y !== to.y
  };
});

// Generate grid levels (concentric polygons) - 1 to 4 scale
const gridLevels = [1, 2, 3, 4];
const gridPolygons = gridLevels.map(level => {
  const points = Array.from({ length: numCategories }, (_, i) => {
    const angle = (i * angleStep) - (Math.PI / 2);
    const radius = (level / maxValue) * maxRadius;
    const x = center + radius * Math.cos(angle);
    const y = center + radius * Math.sin(angle);
    return `${x},${y}`;
  }).join(' ');
  return { level, points };
});

// Generate axis lines from center to each category point
const axisLines = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const x = center + maxRadius * Math.cos(angle);
  const y = center + maxRadius * Math.sin(angle);
  return { x1: center, y1: center, x2: x, y2: y };
});

// Generate label positions (outside the chart)
const labels = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const labelRadius = maxRadius + 50;
  const x = center + labelRadius * Math.cos(angle);
  const y = center + labelRadius * Math.sin(angle);

  // Determine text anchor based on position
  let textAnchor = 'middle';
  if (Math.abs(Math.cos(angle)) > 0.5) {
    textAnchor = Math.cos(angle) > 0 ? 'start' : 'end';
  }

  return { x, y, text: cat.name, textAnchor };
});

// Data polygon points strings for the filled areas
const proficiencyPolygonPoints = proficiencyPoints.map(p => `${p.x},${p.y}`).join(' ');
const experiencePolygonPoints = experiencePoints.map(p => `${p.x},${p.y}`).join(' ');
const proficiencyPolygonPath = `M ${proficiencyPoints.map(p => `${p.x},${p.y}`).join(' L ')} Z`;
const experiencePolygonPath = `M ${experiencePoints.map(p => `${p.x},${p.y}`).join(' L ')} Z`;

// Prepare category data for JavaScript
const categoryData = categories.map((cat, i) => ({
  index: i,
  name: cat.name,
  proficiency: cat.visualProficiency.toFixed(2),
  experience: cat.experience.toFixed(1),
  count: cat.count,
  skills: cat.skills,
  goal: cat.goal,
  goalProficiency: cat.visualGoalProficiency.toFixed(2)
}));

const initialDetailsText = "Hover over a category for details";
---
<div class="component-wrapper">
    <div class="side-by-side-container">
    <div class="chart-wrapper">
        <svg
            viewBox={`0 0 ${size} ${size}`}
            class="radar-chart"
            role="img"
            aria-labelledby="radar-title"
        >
        <title id="radar-title">Skill proficiency and experience radar chart across {numCategories} categories</title>

        <defs>
            <linearGradient id="proficiencyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:var(--color-accent);stop-opacity:0.6" />
            <stop offset="100%" style="stop-color:var(--color-accent-hover);stop-opacity:0.3" />
            </linearGradient>
            <linearGradient id="experienceGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#10b981;stop-opacity:0.5" />
            <stop offset="100%" style="stop-color:#059669;stop-opacity:0.2" />
            </linearGradient>
            <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="8" height="8">
            <path d="M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2"
                    style="stroke:var(--color-accent);stroke-width:1.5;opacity:0.6" />
            </pattern>
            <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5"
            markerWidth="6" markerHeight="6" orient="auto-start-reverse"
            class="migration-arrow-head">
            <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
            <filter id="glow">
            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
            <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
            </filter>
            <filter id="edgeGlow">
            <feGaussianBlur stdDeviation="6" result="softGlow"/>
            <feColorMatrix
                in="softGlow"
                type="matrix"
                values="1 0 0 0 0
                        0 1 0 0 0
                        0 0 1 0 0
                        0 0 0 1.4 0"
                result="boostedGlow"
            />
            <feMerge>
                <feMergeNode in="boostedGlow"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
            </filter>
            <radialGradient id="radarGlowGradient" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="rgba(255, 255, 255, 0.9)" />
            <stop offset="45%" stop-color="rgba(6, 182, 212, 0.4)" />
            <stop offset="100%" stop-color="rgba(6, 182, 212, 0)" />
            </radialGradient>
            <radialGradient id="radarGlowCore" cx="50%" cy="50%" r="50%">
            <stop offset="0%" stop-color="rgba(6, 182, 212, 0.65)" />
            <stop offset="65%" stop-color="rgba(6, 182, 212, 0.1)" />
            <stop offset="100%" stop-color="rgba(6, 182, 212, 0)" />
            </radialGradient>
            <mask id="radarGlowMask">
            <polygon points={experiencePolygonPoints} fill="white" />
            <polygon points={proficiencyPolygonPoints} fill="white" />
            </mask>
        </defs>

        <g class="radar-glow-layer" mask="url(#radarGlowMask)" aria-hidden="true">
            <circle class="radar-glow-spot core" cx={center} cy={center} r={maxRadius} fill="url(#radarGlowCore)" />
            <circle class="radar-glow-spot halo" cx={center} cy={center} r={maxRadius} fill="url(#radarGlowGradient)" />
        </g>

        <!-- Grid background (concentric polygons) -->
        <g class="grid">
            {gridPolygons.map(({ level, points }) => (
            <polygon
                points={points}
                class="grid-level"
                data-level={level}
            />
            ))}
        </g>

        <!-- Axis lines -->
        <g class="axes">
            {axisLines.map((line, i) => (
            <line
                x1={line.x1}
                y1={line.y1}
                x2={line.x2}
                y2={line.y2}
                class="axis-line"
                data-category={i}
            />
            ))}
        </g>

        <!-- Data area (filled polygons) -->
        <g class="data">
            <!-- Experience polygon (behind proficiency) -->
            <polygon
            points={experiencePolygonPoints}
            class="data-polygon experience-polygon"
            fill="url(#experienceGradient)"
            filter="url(#glow)"
            />

            <!-- Proficiency polygon -->
            <polygon
            points={proficiencyPolygonPoints}
            class="data-polygon proficiency-polygon"
            fill="url(#proficiencyGradient)"
            filter="url(#glow)"
            />

            <!-- Goal extension wedges (one per category, shown on hover) -->
            {categories.map((cat, i) => {
            // Create a path for the full polygon with the hovered point moved to its goal
            const goalPolygonPath = proficiencyPoints.map((p, j) => {
                const point = (i === j) ? goalProficiencyPoints[j] : p;
                return `${point.x},${point.y}`;
            }).join(' L ');

            const wedgePath = `M ${goalPolygonPath} Z`;

            return (
                <path
                d={wedgePath}
                class="goal-wedge"
                data-category={i}
                fill="url(#diagonalHatch)"
                />
            );
            })}

            <!-- Migration lines with arrows -->
            {migrationLines.map(line => (
            line.visible && (
                <line
                    x1={line.x1}
                    y1={line.y1}
                    x2={line.x2}
                    y2={line.y2}
                    class="migration-line"
                    data-category={line.categoryIndex}
                    marker-end="url(#arrow)"
                />
            )
            ))}

            <!-- Edge highlight overlays -->
            <path
            d={experiencePolygonPath}
            class="edge-highlight glow experience-highlight"
            filter="url(#edgeGlow)"
            />
            <path
            d={experiencePolygonPath}
            class="edge-highlight sparks experience-highlight"
            filter="url(#edgeGlow)"
            />
            <path
            d={experiencePolygonPath}
            class="edge-highlight core experience-highlight"
            filter="url(#glow)"
            />
            <g class="edge-sparks experience-sparks" aria-hidden="true"></g>
            <path
            d={proficiencyPolygonPath}
            class="edge-highlight glow proficiency-highlight"
            filter="url(#edgeGlow)"
            />
            <path
            d={proficiencyPolygonPath}
            class="edge-highlight sparks proficiency-highlight"
            filter="url(#edgeGlow)"
            />
            <path
            d={proficiencyPolygonPath}
            class="edge-highlight core proficiency-highlight"
            filter="url(#glow)"
            />
            <g class="edge-sparks proficiency-sparks" aria-hidden="true"></g>

            <!-- Experience data points -->
            {experiencePoints.map((point, i) => (
            <g class="data-point-group experience-point" data-category={i}>
                <circle
                cx={point.x}
                cy={point.y}
                r="6"
                class="data-point"
                />
            </g>
            ))}

            <!-- Proficiency data points -->
            {proficiencyPoints.map((point, i) => (
            <g class="data-point-group proficiency-point" data-category={i}>
                <circle
                cx={point.x}
                cy={point.y}
                r="6"
                class="data-point"
                />
            </g>
            ))}
        </g>

        <!-- Category labels -->
        <g class="labels">
            {labels.map((label, i) => (
            <text
                x={label.x}
                y={label.y}
                text-anchor={label.textAnchor}
                class="category-label"
                data-category={i}
            >
                {label.text}
            </text>
            ))}
        </g>
        </svg>
    </div>
    <div class="details-column">
        <div class="details-panel" id="details-panel">
            <div class="details-content initial" id="details-initial-state">
                <p>{initialDetailsText}</p>
            </div>
            <div class="details-content hover-state" id="details-hover-state">
                <div class="tooltip-header" id="details-header"></div>
                <div class="tooltip-content-body">
                <div class="tooltip-row">
                    <span class="tooltip-label">Self-Assessment:</span>
                    <span class="tooltip-value" id="details-proficiency"></span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Avg Experience:</span>
                    <span class="tooltip-value" id="details-experience"></span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Skills:</span>
                    <span class="tooltip-value" id="details-count"></span>
                </div>
                <div class="tooltip-goal" id="details-goal"></div>
                <div class="tooltip-target-value" id="details-target-value"></div>
                <div class="tooltip-skills" id="details-skills"></div>
                </div>
            </div>
        </div>
    </div>
    </div>
    <div class="radar-legend">
        <div class="legend-item">
            <div class="legend-marker proficiency"></div>
            <span>Self-Assessment</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker experience"></div>
            <span>Years of Experience</span>
        </div>
    </div>
</div>

<style>
  .component-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: var(--space-lg);
    gap: var(--space-lg);
  }
  .side-by-side-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: var(--space-2xl);
    width: 100%;
  }

  .chart-wrapper {
    flex: 0 0 50%;
    min-width: 0; /* Allow shrinking */
    padding-left: 5%;
  }

  .details-column {
    flex: 1 1 45%;
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
    min-width: 0;
  }

  .details-panel {
    flex-grow: 1;
    background: var(--color-bg);
    padding: 0;
    height: auto; /* Fixed height */
    overflow-y: auto; /* Scroll if content overflows */
  }

  .details-content.initial {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--color-text-secondary);
    text-align: center;
  }
  
  .details-content.hover-state {
    display: none; /* Hidden by default */
  }

  .details-panel.active .details-content.initial {
    display: none;
  }
  .details-panel.active .details-content.hover-state {
    display: block;
  }


  .radar-chart {
    width: 100%;
    height: 100%;
    filter: drop-shadow(0 4px 12px rgba(1, 255, 255, 0.25));
    overflow: visible;
    display: block;
  }

  .radar-glow-layer {
    pointer-events: none;
    mix-blend-mode: screen;
  }

  .radar-glow-spot {
    opacity: 0.95;
    transition: opacity var(--transition-fast);
  }

  .radar-glow-spot.core {
    opacity: 0.75;
  }

  .radar-glow-spot.halo {
    opacity: 0.6;
  }

  /* Grid styling */
  .grid-level {
    fill: none;
    stroke: rgba(105, 105, 105, 0.788);
    stroke-width: 1;
    opacity: 0.6;
    transition: opacity var(--transition-fast);
  }

  .grid-level:hover {
    opacity: 0.6;
  }

  /* Axis lines */
  .axis-line {
    stroke: var(--color-border);
    stroke-width: 1;
    opacity: 0.4;
  }

  /* Data visualization */
  .data-polygon {
    stroke-width: 2.5;
    transition: all var(--transition-normal);
  }

  .proficiency-polygon {
    fill: url(#proficiencyGradient);
    stroke: var(--color-accent);
    transition: opacity var(--transition-normal);
  }

  .proficiency-polygon.dimmed {
    opacity: 0.2;
  }

  .experience-polygon {
    fill: url(#experienceGradient);
    stroke: #10b981;
  }

  .edge-highlight {
    fill: none;
    stroke-linecap: round;
    stroke-dasharray: var(--highlight-size) calc(var(--path-length) - var(--highlight-size));
    stroke-dashoffset: 0;
    opacity: 0;
    pointer-events: none;
    animation-timing-function: cubic-bezier(0.25, 0.7, 0.2, 1);
    animation-fill-mode: both;
  }

  .edge-highlight.core {
    stroke-width: 2;
    --highlight-size: 5px;
  }

  .edge-highlight.core.animate {
    animation: edge-travel-core 2.8s linear 1;
  }

  .edge-highlight.glow {
    stroke-width: 6;
    mix-blend-mode: screen;
    --highlight-size: 16px;
  }

  .edge-highlight.glow.animate {
    animation: edge-travel-glow 3.2s linear 1;
  }

  .edge-highlight.sparks {
    stroke-width: 2.5;
    opacity: 0.6;
    stroke-dasharray: 2px 10px 2px 12px 2px 8px calc(var(--path-length) - 36px);
  }

  .edge-highlight.sparks.animate {
    animation: edge-travel-sparks 3.8s linear 1;
  }

  :global(.edge-sparks .spark) {
    opacity: 0;
    mix-blend-mode: screen;
    filter: url(#edgeGlow);
  }

  :global(.proficiency-sparks .spark) {
    fill: rgba(6, 182, 212, 0.95);
  }

  :global(.experience-sparks .spark) {
    fill: rgba(16, 185, 129, 0.95);
  }

  .proficiency-highlight {
    stroke: rgba(6, 182, 212, 1);
  }

  .experience-highlight {
    stroke: rgba(16, 185, 129, 1);
  }

  @keyframes edge-travel-core {
    0% {
      opacity: 0;
      stroke-dashoffset: var(--highlight-start-offset, 0px);
    }
    12% {
      opacity: 1;
    }
    60% {
      opacity: 0.85;
    }
    100% {
      opacity: 0;
      stroke-dashoffset: calc(var(--highlight-start-offset, 0px) + var(--highlight-travel-offset));
    }
  }

  @keyframes edge-travel-glow {
    0% {
      opacity: 0;
      stroke-dashoffset: var(--highlight-start-offset, 0px);
    }
    18% {
      opacity: 0.7;
    }
    65% {
      opacity: 0.45;
    }
    100% {
      opacity: 0;
      stroke-dashoffset: calc(var(--highlight-start-offset, 0px) + var(--highlight-travel-offset));
    }
  }

  @keyframes edge-travel-sparks {
    0% {
      opacity: 0;
      stroke-dashoffset: var(--highlight-start-offset, 0px);
    }
    25% {
      opacity: 0.8;
    }
    70% {
      opacity: 0.35;
    }
    100% {
      opacity: 0;
      stroke-dashoffset: calc(var(--highlight-start-offset, 0px) + var(--highlight-travel-offset));
    }
  }

  .goal-wedge {
    stroke: var(--color-accent);
    stroke-width: 2;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-normal);
  }

  .goal-wedge.visible {
    opacity: 1;
  }

  .migration-line {
    stroke: var(--color-accent);
    stroke-width: 2.5;
    stroke-dasharray: 4 4;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-normal);
    animation: dashing 1s linear infinite;
  }

  .migration-line.visible {
    opacity: 0.8;
  }

  .migration-arrow-head {
    fill: var(--color-accent);
  }

  @keyframes dashing {
    from {
      stroke-dashoffset: 16;
    }
    to {
      stroke-dashoffset: 0;
    }
  }

  .data-point {
    stroke: var(--color-bg);
    stroke-width: 2;
    transition: all var(--transition-fast);
    cursor: pointer;
  }

  .proficiency-point .data-point {
    fill: var(--color-accent);
  }

  .experience-point .data-point {
    fill: #10b981;
  }

  .proficiency-point .data-point.highlighted {
    fill: var(--color-accent-hover);
  }

  .experience-point .data-point.highlighted {
    fill: #059669;
  }

  .data-point.dimmed {
    fill: #6b7280 !important;
    opacity: 0.5;
  }

  /* Labels - 2x bigger */
  .category-label {
    fill: var(--color-text-secondary);
    font-size: 26px;
    font-weight: 500;
    font-family: var(--font-sans);
    transition: all var(--transition-fast);
    cursor: pointer;
    user-select: none;
  }

  .category-label.highlighted {
    fill: var(--color-accent);
    font-weight: 600;
  }

  /* Legend */
  .radar-legend {
    display: flex;
    gap: var(--space-xl);
    justify-content: center;
    width: 100%;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 14px;
    color: var(--color-foreground);
  }

  .legend-marker {
    width: 24px;
    height: 12px;
    border-radius: 2px;
    border: 2px solid;
  }

  .legend-marker.proficiency {
    background: var(--color-accent);
    border-color: var(--color-accent);
    opacity: 0.6;
  }

  .legend-marker.experience {
    background: #10b981;
    border-color: #10b981;
    opacity: 0.5;
  }

  /* Tooltip Styles applied to Details Panel */
  .tooltip-header {
    display: none;
  }

  .tooltip-content-body {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .tooltip-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--space-sm);
    font-size: 13px;
  }

  .tooltip-label {
    color: var(--color-text-secondary);
    font-weight: 500;
    font-size: 13px;
  }

  .tooltip-value {
    color: var(--color-foreground);
    font-weight: 600;
    font-size: 13px;
  }

  .tooltip-goal {
    margin-top: 0;
    padding: var(--space-xs);
    background: var(--color-bg);
    border-left: 3px solid var(--color-accent);
    border-radius: 4px;
    font-size: 12px;
    color: var(--color-text-secondary);
    line-height: 1.4;
  }

  .tooltip-target-value {
    margin-top: var(--space-sm); /* Add some space below the goal */
    padding: var(--space-xs);
    background: var(--color-bg-secondary);
    border-radius: 4px;
    font-size: 12px;
    color: var(--color-text-secondary);
    line-height: 1.4;
    display: flex; /* For aligning content within */
    align-items: center;
    justify-content: center;
  }

  .tooltip-skills {
    margin-top: var(--space-sm);
    padding-top: var(--space-sm);
    border-top: 1px solid var(--color-border);
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-xs);
    font-size: 11px;
  }

  .tooltip-skills .skill-tag {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    padding: 2px 6px;
    color: var(--color-text-secondary);
    font-size: 11px;
  }

  .target-display {
    margin-top: var(--space-sm);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .target-values {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-weight: 600;
  }

  /* Responsive adjustments */
  @media (max-width: 1024px) {
    .side-by-side-container {
      flex-direction: column;
    }
    .chart-wrapper {
      width: 100%;
      flex-basis: auto;
    }
    .details-column {
      width: 100%;
      max-width: 750px;
      flex-basis: auto;
    }
  }

  @media (max-width: 768px) {
    .radar-chart {
      max-width: 600px;
    }
    .category-label {
      font-size: 20px;
    }
    .radar-legend {
      flex-direction: column;
      gap: var(--space-sm);
    }
  }

  @media (max-width: 640px) {
    .radar-chart {
      max-width: 450px;
    }
    .category-label {
      font-size: 16px;
    }
  }

  /* Goal animation in details panel */
  .current-prof, .goal-prof {
    font-weight: 600;
  }
</style>

<script define:vars={{ categoryData, proficiencyPoints, experiencePoints, center, maxRadius, initialDetailsText }}>
  document.addEventListener('DOMContentLoaded', () => {
    let activeCategoryIndex = -1;

    const proficiencyPolygon = document.querySelector('.proficiency-polygon');
    const experiencePolygon = document.querySelector('.experience-polygon');
    const proficiencyHighlightCore = document.querySelector('.proficiency-highlight.core');
    const proficiencyHighlightGlow = document.querySelector('.proficiency-highlight.glow');
    const proficiencyHighlightSparks = document.querySelector('.proficiency-highlight.sparks');
    const experienceHighlightCore = document.querySelector('.experience-highlight.core');
    const experienceHighlightGlow = document.querySelector('.experience-highlight.glow');
    const experienceHighlightSparks = document.querySelector('.experience-highlight.sparks');
    const proficiencySparkLayer = document.querySelector('.proficiency-sparks');
    const experienceSparkLayer = document.querySelector('.experience-sparks');
    const chartSvg = document.querySelector('.radar-chart');
    const glowSpots = document.querySelectorAll('.radar-glow-spot');
    const goalWedges = document.querySelectorAll('.goal-wedge');
    const migrationLines = document.querySelectorAll('.migration-line');
    
    const labels = document.querySelectorAll('.category-label');
    const dataPoints = document.querySelectorAll('.data-point-group');
    
    // Details panel elements
    const detailsPanel = document.getElementById('details-panel');
    const detailsHeader = document.getElementById('details-header');
    const detailsProficiency = document.getElementById('details-proficiency');
    const detailsExperience = document.getElementById('details-experience');
    const detailsCount = document.getElementById('details-count');
    const detailsGoal = document.getElementById('details-goal');
    const detailsSkills = document.getElementById('details-skills');
    const detailsTargetValue = document.getElementById('details-target-value');

    const updateDetailsPanel = (category, showGoalExtension = false) => {
      if (!detailsPanel || !category) return;

      if (detailsHeader) detailsHeader.textContent = category.name;
      
      if (detailsProficiency) {
        detailsProficiency.innerHTML = `<span class="current-prof">${category.proficiency}</span>`;
      }
      
      if (detailsTargetValue) {
        detailsTargetValue.style.display = 'none'; // Hide by default
        const proficiencyValue = parseFloat(category.proficiency);
        const goalProficiencyValue = parseFloat(category.goalProficiency);

        if (showGoalExtension && category.goal && proficiencyValue !== goalProficiencyValue) {
            const isIncrease = goalProficiencyValue > proficiencyValue;
            const arrowColor = isIncrease ? 'green' : 'hsl(0, 60%, 50%)';
            const arrowSymbol = isIncrease ? '▲' : '▼'; // Use Unicode triangles
            
            detailsTargetValue.innerHTML = `
              <div class="target-values">
                <span class="current-prof">${category.proficiency}</span>
                <span style="color: ${arrowColor}; font-weight: bold; margin: 0 8px; font-size: 1.2em;">${arrowSymbol}</span>
                <span class="goal-prof visible">${category.goalProficiency}</span>
              </div>
            `;
            detailsTargetValue.style.display = 'flex'; // Show if content
        }
      }
      
      if (detailsExperience) detailsExperience.textContent = `${category.experience} years`;
      if (detailsCount) detailsCount.textContent = category.count;

      if (detailsGoal) {
        if (category.goal) {
          const goalInfo = `<strong>Goal:</strong> ${category.goal.description}`;
          detailsGoal.innerHTML = goalInfo;
          detailsGoal.style.display = 'block';
        } else {
          detailsGoal.style.display = 'none';
        }
      }

      if (detailsSkills) {
        detailsSkills.innerHTML = (category.skills || [])
          .map(skill => `<span class="skill-tag">${skill}</span>`)
          .join('');
      }
      
      detailsPanel.classList.add('active');
    };

    const clearHighlights = (categoryIndex) => {
        if (categoryIndex === -1) return;
        document.querySelector(`.category-label[data-category="${categoryIndex}"]`)?.classList.remove('highlighted');
        proficiencyPolygon?.classList.remove('dimmed');
        goalWedges.forEach(wedge => wedge.classList.remove('visible'));
        migrationLines.forEach(line => line.classList.remove('visible'));
    };

    const setEdgeHighlightMetrics = (element) => {
      if (!(element instanceof SVGPathElement)) return;
      const length = element.getTotalLength();
      element.style.setProperty('--path-length', `${length}px`);
      element.style.setProperty('--highlight-travel-offset', `${-(length * 0.75)}px`);
    };

    const getLocalPoint = (event) => {
      if (!chartSvg || !(chartSvg instanceof SVGSVGElement) || !chartSvg.createSVGPoint) return null;
      const point = chartSvg.createSVGPoint();
      point.x = event.clientX;
      point.y = event.clientY;
      const matrix = chartSvg.getScreenCTM();
      if (!matrix) return null;
      return point.matrixTransform(matrix.inverse());
    };

    const setGlowPosition = (event) => {
      const localPoint = getLocalPoint(event);
      if (!localPoint) return;
      glowSpots.forEach((spot) => {
        if (!(spot instanceof SVGCircleElement)) return;
        spot.setAttribute('cx', localPoint.x.toFixed(2));
        spot.setAttribute('cy', localPoint.y.toFixed(2));
      });
    };

    const resetGlowPosition = () => {
      glowSpots.forEach((spot) => {
        if (!(spot instanceof SVGCircleElement)) return;
        spot.setAttribute('cx', center.toFixed(2));
        spot.setAttribute('cy', center.toFixed(2));
      });
    };

    const getClosestPathOffset = (points, target) => {
      if (!points?.length || !target) return 0;
      let bestDist = Infinity;
      let bestOffset = 0;
      let accumulated = 0;

      for (let i = 0; i < points.length; i++) {
        const start = points[i];
        const end = points[(i + 1) % points.length];
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const segLenSq = dx * dx + dy * dy;
        const segLen = Math.sqrt(segLenSq);
        if (!segLen) continue;

        const t = Math.max(0, Math.min(1, ((target.x - start.x) * dx + (target.y - start.y) * dy) / segLenSq));
        const projX = start.x + t * dx;
        const projY = start.y + t * dy;
        const distSq = (target.x - projX) ** 2 + (target.y - projY) ** 2;

        if (distSq < bestDist) {
          bestDist = distSq;
          bestOffset = accumulated + (t * segLen);
        }

        accumulated += segLen;
      }

      return bestOffset;
    };

    const getPathLengthFromPoints = (points) => {
      if (!points?.length) return 0;
      let total = 0;
      for (let i = 0; i < points.length; i++) {
        const start = points[i];
        const end = points[(i + 1) % points.length];
        total += Math.hypot(end.x - start.x, end.y - start.y);
      }
      return total;
    };

    const getPointAtOffset = (points, offset) => {
      if (!points?.length) return null;
      const total = getPathLengthFromPoints(points);
      let remaining = ((offset % total) + total) % total;

      for (let i = 0; i < points.length; i++) {
        const start = points[i];
        const end = points[(i + 1) % points.length];
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const segLen = Math.hypot(dx, dy);
        if (segLen === 0) continue;
        if (remaining <= segLen) {
          const t = remaining / segLen;
          return {
            x: start.x + t * dx,
            y: start.y + t * dy,
            angle: Math.atan2(dy, dx)
          };
        }
        remaining -= segLen;
      }
      return null;
    };

    const getSparkColor = (baseColor) => {
      const rgb = baseColor.match(/\d+/g)?.map(Number) ?? [255, 255, 255];
      const variance = 35;
      const channel = (value) => Math.max(0, Math.min(255, value + (Math.random() * variance - variance / 2)));
      const [r, g, b] = rgb;
      return `rgba(${channel(r)}, ${channel(g)}, ${channel(b)}, ${0.6 + Math.random() * 0.35})`;
    };

    const spawnSparks = (layer, points, startOffset, baseColor) => {
      if (!(layer instanceof SVGGElement)) return;
      const pathLength = getPathLengthFromPoints(points);
      if (!pathLength) return;

      const sparkCount = 18;
      const sparks = Array.from({ length: sparkCount }, () => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.classList.add('spark');
        circle.setAttribute('r', (0.8 + Math.random() * 2.4).toFixed(2));
        if (baseColor) {
          circle.style.fill = getSparkColor(baseColor);
        }
        layer.appendChild(circle);
        const life = 420 + Math.random() * 900;
        return {
          circle,
          offset: (startOffset - Math.random() * (pathLength * 0.06) + pathLength) % pathLength,
          speed: (pathLength * (0.18 + Math.random() * 0.12)) / life,
          drift: (Math.random() * 2 - 1) * (10 + Math.random() * 14),
          angleOffset: (Math.random() * 0.9 - 0.45),
          life
        };
      });

      const startTime = performance.now();

      const tick = (time) => {
        const elapsed = time - startTime;
        let active = false;

        sparks.forEach((spark) => {
          const age = elapsed;
          if (age >= spark.life) {
            spark.circle.remove();
            return;
          }
          active = true;
          const progress = age / spark.life;
          const offset = spark.offset + (spark.speed * age);
          const point = getPointAtOffset(points, offset);
          if (!point) return;

          const normalAngle = point.angle + (spark.drift >= 0 ? Math.PI / 2 : -Math.PI / 2) + spark.angleOffset;
          const drift = spark.drift * (1 - progress);
          const jitter = (Math.random() - 0.5) * 1.2;
          const x = point.x + Math.cos(normalAngle) * drift + jitter;
          const y = point.y + Math.sin(normalAngle) * drift + jitter;
          spark.circle.setAttribute('cx', x.toFixed(2));
          spark.circle.setAttribute('cy', y.toFixed(2));
          spark.circle.style.opacity = `${0.9 * (1 - progress)}`;
        });

        if (active) {
          requestAnimationFrame(tick);
        }
      };

      requestAnimationFrame(tick);
    };

    const triggerEdgeHighlight = (elements, startOffset = 0, sparkConfig = null) => {
      const [core, glow, sparks] = elements;
      if (!(core instanceof SVGPathElement)) return;
      if (core.dataset.running === 'true') return;
      core.dataset.running = 'true';

      [core, glow, sparks].forEach((element) => {
        if (!(element instanceof SVGPathElement)) return;
        element.style.setProperty('--highlight-start-offset', `${-startOffset}px`);
        element.classList.remove('animate');
      });

      void core.getBoundingClientRect();
      [core, glow, sparks].forEach((element) => {
        if (!(element instanceof SVGPathElement)) return;
        element.classList.add('animate');
      });

      if (sparkConfig) {
        spawnSparks(sparkConfig.layer, sparkConfig.points, startOffset, sparkConfig.color);
      }
    };

    // Hover handler
    const handleMouseEnter = (categoryIndex) => {
        if (typeof categoryIndex !== 'number' || Number.isNaN(categoryIndex)) return;
        if (activeCategoryIndex === categoryIndex) return;

        clearHighlights(activeCategoryIndex);

        const category = categoryData[categoryIndex];
        if (!category) return;

        activeCategoryIndex = categoryIndex;

        // Highlight label
        document.querySelector(`.category-label[data-category="${categoryIndex}"]`)?.classList.add('highlighted');
        
        // Show goal visuals
        proficiencyPolygon?.classList.add('dimmed');
        const wedge = document.querySelector(`.goal-wedge[data-category="${categoryIndex}"]`);
        if (wedge) wedge.classList.add('visible');
        
        const migrationLine = document.querySelector(`.migration-line[data-category="${categoryIndex}"]`);
        if (migrationLine) migrationLine.classList.add('visible');

        // Update details panel
        updateDetailsPanel(category, true);
    }
    
    // Add hover handlers for category labels
    labels.forEach((label) => {
      const raw = label.getAttribute('data-category');
      const categoryIndex = raw ? parseInt(raw, 10) : NaN;
      label.addEventListener('mouseenter', (event) => {
        handleMouseEnter(categoryIndex);
        const localPoint = getLocalPoint(event);
        const proficiencyOffset = getClosestPathOffset(proficiencyPoints, localPoint);
        const experienceOffset = getClosestPathOffset(experiencePoints, localPoint);
        triggerEdgeHighlight(
          [proficiencyHighlightCore, proficiencyHighlightGlow, proficiencyHighlightSparks],
          proficiencyOffset,
          { layer: proficiencySparkLayer, points: proficiencyPoints, color: '6, 182, 212' }
        );
        triggerEdgeHighlight(
          [experienceHighlightCore, experienceHighlightGlow, experienceHighlightSparks],
          experienceOffset,
          { layer: experienceSparkLayer, points: experiencePoints, color: '16, 185, 129' }
        );
      });
    });

    // Add hover handlers for data points (dots)
    dataPoints.forEach((pointGroup) => {
      const raw = pointGroup.getAttribute('data-category');
      const categoryIndex = raw ? parseInt(raw, 10) : NaN;
      pointGroup.addEventListener('mouseenter', () => handleMouseEnter(categoryIndex));
    });

    [
      proficiencyHighlightCore,
      proficiencyHighlightGlow,
      proficiencyHighlightSparks,
      experienceHighlightCore,
      experienceHighlightGlow,
      experienceHighlightSparks
    ].forEach((element) => {
      setEdgeHighlightMetrics(element);
    });

    const wireHighlightReset = (core, glow, sparks) => {
      if (!(core instanceof SVGPathElement)) return;
      core.addEventListener('animationend', () => {
        core.dataset.running = 'false';
        [core, glow, sparks].forEach((element) => {
          if (element instanceof SVGPathElement) {
            element.classList.remove('animate');
          }
        });
      });
    };

    wireHighlightReset(proficiencyHighlightCore, proficiencyHighlightGlow, proficiencyHighlightSparks);
    wireHighlightReset(experienceHighlightCore, experienceHighlightGlow, experienceHighlightSparks);

    proficiencyPolygon?.addEventListener('mouseenter', (event) => {
      const localPoint = getLocalPoint(event);
      const startOffset = getClosestPathOffset(proficiencyPoints, localPoint);
      triggerEdgeHighlight(
        [proficiencyHighlightCore, proficiencyHighlightGlow, proficiencyHighlightSparks],
        startOffset,
        { layer: proficiencySparkLayer, points: proficiencyPoints, color: '6, 182, 212' }
      );
    });

    experiencePolygon?.addEventListener('mouseenter', (event) => {
      const localPoint = getLocalPoint(event);
      const startOffset = getClosestPathOffset(experiencePoints, localPoint);
      triggerEdgeHighlight(
        [experienceHighlightCore, experienceHighlightGlow, experienceHighlightSparks],
        startOffset,
        { layer: experienceSparkLayer, points: experiencePoints, color: '16, 185, 129' }
      );
    });

    if (chartSvg) {
      let frame = 0;
      const handleGlowMove = (event) => {
        if (frame) return;
        frame = requestAnimationFrame(() => {
          frame = 0;
          setGlowPosition(event);
        });
      };
      chartSvg.addEventListener('pointermove', handleGlowMove);
      chartSvg.addEventListener('pointerleave', resetGlowPosition);
      resetGlowPosition();
    }

    // Set initial state: prefer 'Programming Languages', fallback to first category
    const initialCategoryName = 'Programming Languages';
    let initialCategoryIndex = categoryData.findIndex(cat => cat.name === initialCategoryName);
    if (initialCategoryIndex === -1 && categoryData.length > 0) initialCategoryIndex = 0;
    if (initialCategoryIndex !== -1) {
        // Ensure UI shows the initial category details even if there are no hover events
        handleMouseEnter(initialCategoryIndex);
    }
  });
</script>
