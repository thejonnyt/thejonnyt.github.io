---
/**
 * SkillsRadar.astro - Interactive radar/spider chart for skill categories
 */
import skillsDatabase from '../content/skillsDatabase.json';

interface Props {
  size?: number;
}

const { size = 750 } = Astro.props;

// Map skill levels to numeric values (0-5)
const levelToValue: Record<string, number> = {
  'beginner': 1,
  'competent': 2,
  'proficient': 3,
  'expert': 4,
  'wizard': 5
};

// Calculate average proficiency and years of experience per category
const categoryStats: Record<string, {
  sumProficiency: number;
  sumExperience: number;
  count: number;
  skills: string[]
}> = {};

for (const key in skillsDatabase.skills) {
  const k = key as keyof typeof skillsDatabase.skills;
  const skill = skillsDatabase.skills[k];
  const category = skill.category;
  const proficiencyValue = levelToValue[skill.level] || 0;
  const experienceYears = skill.yearsOfExperience || 0;

  if (!categoryStats[category]) {
    categoryStats[category] = { sumProficiency: 0, sumExperience: 0, count: 0, skills: [] };
  }

  categoryStats[category].sumProficiency += proficiencyValue;
  categoryStats[category].sumExperience += experienceYears;
  categoryStats[category].count++;
  categoryStats[category].skills.push(key);
}

// Calculate averages and prepare data, filtering out Business & Strategy
const categories = Object.entries(categoryStats)
  .filter(([name]) => name !== 'Business & Strategy')
  .map(([name, stats]) => {
    const avgProficiency = stats.sumProficiency / stats.count;
    const avgExperience = stats.sumExperience / stats.count;
    // Scale experience: 5 years = 4.0 on visual scale
    const visualExperience = Math.min((avgExperience / 5) * 4, 4);

    const goal = skillsDatabase.categoryGoals?.[name];
    return {
      name,
      proficiency: avgProficiency,
      visualProficiency: Math.min(avgProficiency, 4), // Clamped to 4 for display
      experience: avgExperience,
      visualExperience: visualExperience,
      count: stats.count,
      skills: stats.skills,
      goal: goal || null,
      goalProficiency: goal?.proficiencyTarget || avgProficiency,
      visualGoalProficiency: Math.min(goal?.proficiencyTarget || avgProficiency, 4)
    };
  });

// SVG configuration
const center = size / 2;
const maxRadius = (size / 2) - 70; // More space for labels
const numCategories = categories.length;
const maxValue = 4; // Visual scale is 1-4

// Generate polygon points for the radar chart
const angleStep = (2 * Math.PI) / numCategories;

// Data points for proficiency
const proficiencyPoints = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2); // Start at top
  const radius = (cat.visualProficiency / maxValue) * maxRadius;
  const x = center + radius * Math.cos(angle);
  const y = center + radius * Math.sin(angle);
  return { x, y, angle, cat };
});

// Data points for experience
const experiencePoints = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const radius = (cat.visualExperience / maxValue) * maxRadius;
  const x = center + radius * Math.cos(angle);
  const y = center + radius * Math.sin(angle);
  return { x, y, angle, cat };
});

// Data points for goal proficiency (for extension visualization)
const goalProficiencyPoints = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const radius = (cat.visualGoalProficiency / maxValue) * maxRadius;
  const x = center + radius * Math.cos(angle);
  const y = center + radius * Math.sin(angle);
  return { x, y, angle, cat };
});

// Generate lines for migration animation
const migrationLines = categories.map((_, i) => {
  const from = proficiencyPoints[i];
  const to = goalProficiencyPoints[i];
  return {
    x1: from.x,
    y1: from.y,
    x2: to.x,
    y2: to.y,
    categoryIndex: i,
    // Only create a line if there's a difference
    visible: from.x !== to.x || from.y !== to.y
  };
});

// Generate grid levels (concentric polygons) - 1 to 4 scale
const gridLevels = [1, 2, 3, 4];
const gridPolygons = gridLevels.map(level => {
  const points = Array.from({ length: numCategories }, (_, i) => {
    const angle = (i * angleStep) - (Math.PI / 2);
    const radius = (level / maxValue) * maxRadius;
    const x = center + radius * Math.cos(angle);
    const y = center + radius * Math.sin(angle);
    return `${x},${y}`;
  }).join(' ');
  return { level, points };
});

// Generate axis lines from center to each category point
const axisLines = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const x = center + maxRadius * Math.cos(angle);
  const y = center + maxRadius * Math.sin(angle);
  return { x1: center, y1: center, x2: x, y2: y };
});

// Generate label positions (outside the chart)
const labels = categories.map((cat, i) => {
  const angle = (i * angleStep) - (Math.PI / 2);
  const labelRadius = maxRadius + 50;
  const x = center + labelRadius * Math.cos(angle);
  const y = center + labelRadius * Math.sin(angle);

  // Determine text anchor based on position
  let textAnchor = 'middle';
  if (Math.abs(Math.cos(angle)) > 0.5) {
    textAnchor = Math.cos(angle) > 0 ? 'start' : 'end';
  }

  return { x, y, text: cat.name, textAnchor };
});

// Data polygon points strings for the filled areas
const proficiencyPolygonPoints = proficiencyPoints.map(p => `${p.x},${p.y}`).join(' ');
const experiencePolygonPoints = experiencePoints.map(p => `${p.x},${p.y}`).join(' ');

// Prepare category data for JavaScript
const categoryData = categories.map((cat, i) => ({
  index: i,
  name: cat.name,
  proficiency: cat.visualProficiency.toFixed(2),
  experience: cat.experience.toFixed(1),
  count: cat.count,
  skills: cat.skills,
  goal: cat.goal,
  goalProficiency: cat.visualGoalProficiency.toFixed(2)
}));

const initialDetailsText = "Hover over a category for details";
---
<div class="component-wrapper">
    <div class="side-by-side-container">
    <div class="chart-wrapper">
        <svg
        viewBox={`0 0 ${size} ${size}`}
        class="radar-chart"
        role="img"
        aria-labelledby="radar-title"
        >
        <title id="radar-title">Skill proficiency and experience radar chart across {numCategories} categories</title>

        <defs>
            <linearGradient id="proficiencyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:var(--color-accent);stop-opacity:0.6" />
            <stop offset="100%" style="stop-color:var(--color-accent-hover);stop-opacity:0.3" />
            </linearGradient>
            <linearGradient id="experienceGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#10b981;stop-opacity:0.5" />
            <stop offset="100%" style="stop-color:#059669;stop-opacity:0.2" />
            </linearGradient>
            <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="8" height="8">
            <path d="M-1,1 l2,-2 M0,8 l8,-8 M7,9 l2,-2"
                    style="stroke:var(--color-accent);stroke-width:1.5;opacity:0.6" />
            </pattern>
            <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5"
            markerWidth="6" markerHeight="6" orient="auto-start-reverse"
            class="migration-arrow-head">
            <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
            <filter id="glow">
            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
            <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
            </filter>
        </defs>

        <!-- Grid background (concentric polygons) -->
        <g class="grid">
            {gridPolygons.map(({ level, points }) => (
            <polygon
                points={points}
                class="grid-level"
                data-level={level}
            />
            ))}
        </g>

        <!-- Axis lines -->
        <g class="axes">
            {axisLines.map((line, i) => (
            <line
                x1={line.x1}
                y1={line.y1}
                x2={line.x2}
                y2={line.y2}
                class="axis-line"
                data-category={i}
            />
            ))}
        </g>

        <!-- Data area (filled polygons) -->
        <g class="data">
            <!-- Experience polygon (behind proficiency) -->
            <polygon
            points={experiencePolygonPoints}
            class="data-polygon experience-polygon"
            />

            <!-- Proficiency polygon -->
            <polygon
            points={proficiencyPolygonPoints}
            class="data-polygon proficiency-polygon"
            />

            <!-- Goal extension wedges (one per category, shown on hover) -->
            {categories.map((cat, i) => {
            // Create a path for the full polygon with the hovered point moved to its goal
            const goalPolygonPath = proficiencyPoints.map((p, j) => {
                const point = (i === j) ? goalProficiencyPoints[j] : p;
                return `${point.x},${point.y}`;
            }).join(' L ');

            const wedgePath = `M ${goalPolygonPath} Z`;

            return (
                <path
                d={wedgePath}
                class="goal-wedge"
                data-category={i}
                />
            );
            })}

            <!-- Migration lines with arrows -->
            {migrationLines.map(line => (
            line.visible && (
                <line
                    x1={line.x1}
                    y1={line.y1}
                    x2={line.x2}
                    y2={line.y2}
                    class="migration-line"
                    data-category={line.categoryIndex}
                    marker-end="url(#arrow)"
                />
            )
            ))}

            <!-- Experience data points -->
            {experiencePoints.map((point, i) => (
            <g class="data-point-group experience-point" data-category={i}>
                <circle
                cx={point.x}
                cy={point.y}
                r="6"
                class="data-point"
                />
            </g>
            ))}

            <!-- Proficiency data points -->
            {proficiencyPoints.map((point, i) => (
            <g class="data-point-group proficiency-point" data-category={i}>
                <circle
                cx={point.x}
                cy={point.y}
                r="6"
                class="data-point"
                />
            </g>
            ))}
        </g>

        <!-- Category labels -->
        <g class="labels">
            {labels.map((label, i) => (
            <text
                x={label.x}
                y={label.y}
                text-anchor={label.textAnchor}
                class="category-label"
                data-category={i}
            >
                {label.text}
            </text>
            ))}
        </g>
        </svg>
    </div>
    <div class="details-column">
        <div class="details-panel" id="details-panel">
            <div class="details-content initial" id="details-initial-state">
                <p>{initialDetailsText}</p>
            </div>
            <div class="details-content hover-state" id="details-hover-state">
                <div class="tooltip-header" id="details-header"></div>
                <div class="tooltip-content-body">
                <div class="tooltip-row">
                    <span class="tooltip-label">Self-Assessment:</span>
                    <span class="tooltip-value" id="details-proficiency"></span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Avg Experience:</span>
                    <span class="tooltip-value" id="details-experience"></span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Skills:</span>
                    <span class="tooltip-value" id="details-count"></span>
                </div>
                <div class="tooltip-goal" id="details-goal"></div>
                <div class="tooltip-skills" id="details-skills"></div>
                </div>
            </div>
        </div>
    </div>
    </div>
    <div class="radar-legend">
        <div class="legend-item">
            <div class="legend-marker proficiency"></div>
            <span>Self-Assessment</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker experience"></div>
            <span>Years of Experience</span>
        </div>
    </div>
</div>

<style>
  .component-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: var(--space-lg);
    gap: var(--space-lg);
  }
  .side-by-side-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: var(--space-2xl);
    width: 100%;
  }

  .chart-wrapper {
    flex: 0 0 50%;
    min-width: 0; /* Allow shrinking */
    padding-left: 5%;
  }

  .details-column {
    flex: 1 1 45%;
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
    min-width: 0;
  }

  .details-panel {
    flex-grow: 1;
    background: var(--color-bg);
    padding: 0;
    height: auto; /* Fixed height */
    overflow-y: auto; /* Scroll if content overflows */
  }

  .details-content.initial {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--color-text-secondary);
    text-align: center;
  }
  
  .details-content.hover-state {
    display: none; /* Hidden by default */
  }

  .details-panel.active .details-content.initial {
    display: none;
  }
  .details-panel.active .details-content.hover-state {
    display: block;
  }


  .radar-chart {
    width: 100%;
    height: 100%;
    filter: drop-shadow(0 4px 12px rgba(1, 255, 255, 0.25));
    overflow: visible;
  }

  /* Grid styling */
  .grid-level {
    fill: none;
    stroke: rgba(105, 105, 105, 0.788);
    stroke-width: 1;
    opacity: 0.6;
    transition: opacity var(--transition-fast);
  }

  .grid-level:hover {
    opacity: 0.6;
  }

  /* Axis lines */
  .axis-line {
    stroke: var(--color-border);
    stroke-width: 1;
    opacity: 0.4;
  }

  /* Data visualization */
  .data-polygon {
    stroke-width: 2.5;
    filter: url(#glow);
    transition: all var(--transition-normal);
  }

  .proficiency-polygon {
    fill: url(#proficiencyGradient);
    stroke: var(--color-accent);
    transition: opacity var(--transition-normal);
  }

  .proficiency-polygon.dimmed {
    opacity: 0.2;
  }

  .experience-polygon {
    fill: url(#experienceGradient);
    stroke: #10b981;
  }

  .goal-wedge {
    fill: url(#diagonalHatch);
    stroke: var(--color-accent);
    stroke-width: 2;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-normal);
  }

  .goal-wedge.visible {
    opacity: 1;
  }

  .migration-line {
    stroke: var(--color-accent);
    stroke-width: 2.5;
    stroke-dasharray: 4 4;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-normal);
    animation: dashing 1s linear infinite;
  }

  .migration-line.visible {
    opacity: 0.8;
  }

  .migration-arrow-head {
    fill: var(--color-accent);
  }

  @keyframes dashing {
    from {
      stroke-dashoffset: 16;
    }
    to {
      stroke-dashoffset: 0;
    }
  }

  .data-point {
    stroke: var(--color-bg);
    stroke-width: 2;
    transition: all var(--transition-fast);
    cursor: pointer;
  }

  .proficiency-point .data-point {
    fill: var(--color-accent);
  }

  .experience-point .data-point {
    fill: #10b981;
  }

  .data-point.highlighted {
    filter: url(#glow);
  }

  .proficiency-point .data-point.highlighted {
    fill: var(--color-accent-hover);
  }

  .experience-point .data-point.highlighted {
    fill: #059669;
  }

  .data-point.dimmed {
    fill: #6b7280 !important;
    opacity: 0.5;
  }

  /* Labels - 2x bigger */
  .category-label {
    fill: var(--color-text-secondary);
    font-size: 26px;
    font-weight: 500;
    font-family: var(--font-sans);
    transition: all var(--transition-fast);
    cursor: pointer;
    user-select: none;
  }

  .category-label.highlighted {
    fill: var(--color-accent);
    font-weight: 600;
  }

  /* Legend */
  .radar-legend {
    display: flex;
    gap: var(--space-xl);
    justify-content: center;
    width: 100%;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: 14px;
    color: var(--color-foreground);
  }

  .legend-marker {
    width: 24px;
    height: 12px;
    border-radius: 2px;
    border: 2px solid;
  }

  .legend-marker.proficiency {
    background: var(--color-accent);
    border-color: var(--color-accent);
    opacity: 0.6;
  }

  .legend-marker.experience {
    background: #10b981;
    border-color: #10b981;
    opacity: 0.5;
  }

  /* Tooltip Styles applied to Details Panel */
  .tooltip-header {
    display: none;
  }

  .tooltip-content-body {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .tooltip-row {
    display: flex;
    justify-content: space-between;
    gap: var(--space-sm);
    font-size: 13px;
  }

  .tooltip-label {
    color: var(--color-text-secondary);
    font-weight: 500;
    font-size: 13px;
  }

  .tooltip-value {
    color: var(--color-foreground);
    font-weight: 600;
    font-size: 13px;
  }

  .tooltip-goal {
    margin-top: 0;
    padding: var(--space-xs);
    background: var(--color-bg);
    border-left: 3px solid var(--color-accent);
    border-radius: 4px;
    font-size: 12px;
    color: var(--color-text-secondary);
    line-height: 1.4;
  }

  .tooltip-skills {
    margin-top: var(--space-sm);
    padding-top: var(--space-sm);
    border-top: 1px solid var(--color-border);
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-xs);
    font-size: 11px;
  }

  .tooltip-skills .skill-tag {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    padding: 2px 6px;
    color: var(--color-text-secondary);
    font-size: 11px;
  }

  .target-display {
    margin-top: var(--space-sm);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .target-values {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-weight: 600;
  }

  .animated-arrow {
    display: inline-block;
    flex-shrink: 0;
    width: 30px;
    height: 2px;
    background-image: linear-gradient(to right, var(--color-accent) 75%, transparent 25%);
    background-size: 8px 2px;
    background-repeat: repeat-x;
    animation: dashing-html 0.8s linear infinite;
    position: relative;
  }

  .animated-arrow::after {
      content: "";
      position: absolute;
      right: -3px;
      top: -3px;
      border: solid var(--color-accent);
      border-width: 0 2px 2px 0;
      display: inline-block;
      padding: 3px;
      transform: rotate(-45deg);
  }

  @keyframes dashing-html {
      from { background-position-x: 0; }
      to { background-position-x: -16px; }
  }

  /* Responsive adjustments */
  @media (max-width: 1024px) {
    .side-by-side-container {
      flex-direction: column;
    }
    .chart-wrapper {
      width: 100%;
      flex-basis: auto;
    }
    .details-column {
      width: 100%;
      max-width: 750px;
      flex-basis: auto;
    }
  }

  @media (max-width: 768px) {
    .radar-chart {
      max-width: 600px;
    }
    .category-label {
      font-size: 20px;
    }
    .radar-legend {
      flex-direction: column;
      gap: var(--space-sm);
    }
  }

  @media (max-width: 640px) {
    .radar-chart {
      max-width: 450px;
    }
    .category-label {
      font-size: 16px;
    }
  }
</style>

<script define:vars={{ categoryData, proficiencyPoints, center, maxRadius, initialDetailsText }}>
  document.addEventListener('DOMContentLoaded', () => {
    let activeCategoryIndex = -1;

    const proficiencyPolygon = document.querySelector('.proficiency-polygon');
    const goalWedges = document.querySelectorAll('.goal-wedge');
    const migrationLines = document.querySelectorAll('.migration-line');
    
    const labels = document.querySelectorAll('.category-label');
    const dataPoints = document.querySelectorAll('.data-point-group');
    
    // Details panel elements
    const detailsPanel = document.getElementById('details-panel');
    const detailsHeader = document.getElementById('details-header');
    const detailsProficiency = document.getElementById('details-proficiency');
    const detailsExperience = document.getElementById('details-experience');
    const detailsCount = document.getElementById('details-count');
    const detailsGoal = document.getElementById('details-goal');
    const detailsSkills = document.getElementById('details-skills');

    const updateDetailsPanel = (category, showGoalExtension = false) => {
      if (!detailsPanel || !category) return;

      detailsHeader.textContent = category.name;
      detailsProficiency.textContent = `${category.proficiency} / 4.0`;
      detailsExperience.textContent = `${category.experience} years`;
      detailsCount.textContent = category.count;

      if (category.goal) {
        let goalInfo = `<strong>Goal:</strong> ${category.goal.description}`;
        if (showGoalExtension && parseFloat(category.proficiency) < parseFloat(category.goalProficiency)) {
          goalInfo += `<div class="target-display">
            <strong>Target:</strong>
            <span class="target-values">
              <span>${category.proficiency}</span>
              <span class="animated-arrow"></span>
              <span>${category.goalProficiency}</span>
            </span>
          </div>`;
        } else if (showGoalExtension) {
          goalInfo += `<div class="target-display"><strong>Target:</strong> ${category.goalProficiency} / 4.00</div>`;
        }
        detailsGoal.innerHTML = goalInfo;
        detailsGoal.style.display = 'block';
      } else {
        detailsGoal.style.display = 'none';
      }

      detailsSkills.innerHTML = category.skills
        .map(skill => `<span class="skill-tag">${skill}</span>`)
        .join('');
      
      detailsPanel.classList.add('active');
    };

    const clearHighlights = (categoryIndex) => {
        if (categoryIndex === -1) return;
        document.querySelector(`.category-label[data-category="${categoryIndex}"]`)?.classList.remove('highlighted');
        proficiencyPolygon.classList.remove('dimmed');
        goalWedges.forEach(wedge => wedge.classList.remove('visible'));
        migrationLines.forEach(line => line.classList.remove('visible'));
    };

    // Hover handler
    const handleMouseEnter = (categoryIndex) => {
        if (activeCategoryIndex === categoryIndex) return;

        clearHighlights(activeCategoryIndex);

        const category = categoryData[categoryIndex];
        if (!category) return;

        activeCategoryIndex = categoryIndex;

        // Highlight label
        document.querySelector(`.category-label[data-category="${categoryIndex}"]`)?.classList.add('highlighted');
        
        // Show goal visuals
        proficiencyPolygon.classList.add('dimmed');
        const wedge = document.querySelector(`.goal-wedge[data-category="${categoryIndex}"]`);
        if (wedge) wedge.classList.add('visible');
        
        const migrationLine = document.querySelector(`.migration-line[data-category="${categoryIndex}"]`);
        if (migrationLine) migrationLine.classList.add('visible');

        // Update details panel
        updateDetailsPanel(category, true);
    }
    
    // Add hover handlers for category labels
    labels.forEach((label) => {
      const categoryIndex = parseInt(label.getAttribute('data-category'));
      label.addEventListener('mouseenter', () => handleMouseEnter(categoryIndex));
    });

    // Add hover handlers for data points (dots)
    dataPoints.forEach((pointGroup) => {
      const categoryIndex = parseInt(pointGroup.getAttribute('data-category'));
      pointGroup.addEventListener('mouseenter', () => handleMouseEnter(categoryIndex));
    });

    // Set initial state
    const initialCategoryName = 'Programming Languages';
    const initialCategoryIndex = categoryData.findIndex(cat => cat.name === initialCategoryName);
    if (initialCategoryIndex !== -1) {
        handleMouseEnter(initialCategoryIndex);
    }
  });
</script>